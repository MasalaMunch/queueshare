"use strict";

const assert = require(`assert`);
const define = require(`define`);
const doNothing = require(`do-nothing`);
const eventually = require(`eventually`);
const freeze = require(`freeze`);
const LocalVersion = require(`./LocalVersion.js`);
const RedBlackTree = require(`bintrees`).RBTree;
const ShallowCopy = require(`shallow-copy`);
const Tree = require(`./Tree.js`);
const Version = require(`./Version.js`);

module.exports = class {

    constructor (config) {

        config = ShallowCopy(config);

        define(config, {onChange: doNothing});

        const {onChange} = config;

        assert(typeof onChange === `function`);

        this._onChange = onChange;

        this._localVersion = LocalVersion.oldest;

        this._localVersionChanges = new Map();

        this._localVersionTree = new RedBlackTree(LocalVersion.Comparison);

        this._tree = new Tree();

    }

    *Changes () {

        yield* this.ChangesSince();

    }

    *ChangesSince (localVersion) {

        if (localVersion === undefined) {

            localVersion = LocalVersion.oldest;

        }
        else {

            LocalVersion.validate(localVersion);

        }

        const iterator = this._localVersionTree.upperBound(localVersion);

        while (iterator.data() !== null) {

            yield this._localVersionChanges.get(iterator.data());

            iterator.next();

        }

    }

    LocalVersion () {

        return this._localVersion;

    }

    receive (foreignChange) {

        foreignChange = this._NormalizedForeignChange(foreignChange);

        this._receive(foreignChange);

    }

    restore (change) {

        change = this._NormalizedChange(change);

        this._receive(change);

    }

    write (localChange) {

        localChange = this._NormalizedLocalChange(localChange);

        this._foreignify(localChange);

        this._write(localChange);

    }

    _changify (foreignChange, localVersion) {

        if (localVersion === undefined) {

            foreignChange.localVersion = LocalVersion.Newer(this._localVersion);

        }
        else {

            foreignChange.localVersion = LocalVersion.Copy(localVersion);

        }

        foreignChange.Path = Array.from(foreignChange.Path);

        foreignChange.versions = foreignChange.versions.map(Version.Copy);

        freeze(foreignChange);

    }

    _foreignify (localChange, versions) {

        if (versions === undefined) {

            versions = this._tree.Versions(localChange.Path);

            const targetVersion = versions[versions.length-1];

            versions[versions.length-1] = Version.Newer(targetVersion);

        }

        localChange.versions = versions;

    }

    _IsForeignChange (foreignChangeOrChange) {

        return (foreignChangeOrChange.localVersion === undefined);

    }

    _NormalizedChange (change) {

        const foreignChange = this._NormalizedForeignChange(change);

        const {localVersion} = change;

        LocalVersion.validate(localVersion);

        assert(!this._localVersionChanges.has(localVersion));

        this._changify(foreignChange, localVersion);

        return foreignChange;

    }

    _NormalizedForeignChange (foreignChange) {

        const localChange = this._NormalizedLocalChange(foreignChange);

        const {versions} = foreignChange;

        assert(Array.isArray(versions));

        assert(versions.length === 1 + localChange.Path.length);

        versions.forEach(Version.validate);

        this._foreignify(localChange, versions);

        return localChange;

    }

    _NormalizedLocalChange (localChange) {

        const {Path, value} = localChange;

        assert(Array.isArray(Path));

        Path.forEach((child) => assert(typeof child === `string`));

        return {

            Path,

            value: value === undefined? value : JSON.parse(JSON.stringify(value)),

            };

    }

    _receive (foreignChangeOrChange) {

        const {Path, versions} = foreignChangeOrChange;

        let i = 0;

        for (const tree of this._tree.iterativelyBuild(Path)) {

            const versionComparison = 
                Version.Comparison(versions[i], tree.version);

            if (versionComparison !== 0) {

                if (versionComparison > 0) {

                    if (i === versions.length-1) {

                        this._write(foreignChangeOrChange);

                    }
                    else {

                        tree.pendingFuncs.push(() => {

                            this._receive(foreignChangeOrChange);

                        });

                    }

                }

                break;

            }

            i++;

        }

    }

    _write (foreignChangeOrChange) {

        if (this._IsForeignChange(foreignChangeOrChange)) {

            this._changify(foreignChangeOrChange);

        }

        const change = foreignChangeOrChange;

        const {Path, versions, localVersion} = change;

        if (LocalVersion.Comparison(localVersion, this._localVersion) > 0) {

            this._localVersion = localVersion;

        }

        this._localVersionChanges.set(localVersion, change);

        this._localVersionTree.insert(localVersion);

        const tree = this._tree.build(Path);

        for (const {localVersion: oldLocalVersion} of tree.Traversal()) {

            this._localVersionChanges.delete(oldLocalVersion);

            this._localVersionTree.remove(oldLocalVersion);

        }

        tree.childTrees = new Map();

        tree.localVersion = localVersion;

        tree.pendingFuncs.forEach(eventually);

        tree.pendingFuncs = [];

        tree.version = versions[versions.length-1];

        this._onChange(change);

    }

    };